#pragma once
#include <ProcessInterface/TimeValue.hpp>
#include <iscore/tools/SettableIdentifier.hpp>

#include <Process/ScenarioModel.hpp>
#include <Document/Constraint/ConstraintModel.hpp>
#include <Document/Event/EventModel.hpp>
#include <Document/TimeNode/TimeNodeModel.hpp>

/**
 * @brief The displacementPolicy class
 * This class allows to implement multiple displacement behaviors.
 */
class DisplacementPolicy
{
    /**
     * @brief computeDisplacement
     * This function (used by move commands) compute the displcements generated by moving one or more timenodes
     * @param draggedElements
     * Elements of the scenario which were moved by the user
     * @param deltaTime
     * @return
     * the elements affected by the moving process and their old and new parameters (dates and durations)
     * like so : < <tnode, <oldDate, newDate> >, <constraint, <oldMinDuration, newMinDuration>, <oldMaxDuration, newMaxDuration>> >
     */
    virtual
    std::tuple<
        QVector<QPair<Id<TimeNodeModel>, QPair<TimeValue,TimeValue> > >,
        QVector<std::tuple<Id<ConstraintModel>, QPair<TimeValue,TimeValue>, QPair<TimeValue,TimeValue> > >
    >
    computeDisplacement(
            QVector<Id<TimeNodeModel>> draggedElements,
            const TimeValue& deltaTime) = 0;

    /**
     * @brief updatePositions
     * @param elementsToUpdate
     */

    virtual
    void
    updatePositions(std::tuple<
                        QVector<QPair<Id<TimeNodeModel>, QPair<TimeValue,TimeValue> > >,
                        QVector<std::tuple<Id<ConstraintModel>, QPair<TimeValue,TimeValue>, QPair<TimeValue,TimeValue> > >
                    >
                    elementsToUpdate);
};

class GoodOldDisplacementPolicy : DisplacementPolicy
{

};


namespace StandardDisplacementPolicy
{
    // pick out each timeNode that need to move when firstTimeNodeMovedId is moving
    void getRelatedTimeNodes(
            ScenarioModel& scenario,
            const Id<TimeNodeModel>& firstTimeNodeMovedId,
            QVector<Id<TimeNodeModel> >& translatedTimeNodes);


    template<typename ProcessScaleMethod>
    void updatePositions(
            ScenarioModel& scenario,
            const QVector<Id<TimeNodeModel> >& translatedTimeNodes,
            const TimeValue& deltaTime,
            ProcessScaleMethod&& scaleMethod)
    {
        for (const auto& timeNode_id : translatedTimeNodes)
        {
            auto& timeNode = scenario.timeNode(timeNode_id);
            timeNode.setDate(timeNode.date() + deltaTime);
            for (const auto& event : timeNode.events())
            {
                scenario.event(event).setDate(timeNode.date());
            }
        }

        for(auto& constraint : scenario.constraints)
        {
            const auto& startDate = scenario.event(scenario.state(constraint.startState()).eventId()).date();
            const auto& endDate = scenario.event(scenario.state(constraint.endState()).eventId()).date();

            TimeValue newDuration = endDate - startDate;

            if (!(constraint.startDate() - startDate).isZero())
            {
                constraint.setStartDate(startDate);
            }

            if(!(constraint.duration.defaultDuration() - newDuration).isZero())
            {
                ConstraintDurations::Algorithms::setDurationInBounds(constraint, newDuration);
                for(auto& process : constraint.processes)
                {
                    scaleMethod(process, newDuration);
                }
            }

            emit scenario.constraintMoved(constraint);
        }
    }
}
