#pragma once
#include <ProcessInterface/TimeValue.hpp>
#include <iscore/tools/SettableIdentifier.hpp>

#include <Process/ScenarioModel.hpp>
#include <Document/Constraint/ConstraintModel.hpp>
#include <Document/Event/EventModel.hpp>
#include <Document/TimeNode/TimeNodeModel.hpp>

#include "Tools/dataStructures.hpp"

/**
 * @brief The displacementPolicy class
 * This class allows to implement multiple displacement behaviors.
 */
class CommonDisplacementPolicy
{
public:
    /**
     * @brief computeDisplacement
     * This function (used by move commands) compute the displcements generated by moving one or more timenodes
     * @param draggedElements
     * Elements of the scenario which were moved by the user
     * @param deltaTime
     * the amount of time moved
     * @param elementsProperties
     * the elements affected by the moving process and their old and new parameters (dates and durations) will be stored here.
     * IMPORTANT : elementsProperties may not be empty (in case of an update), in such case old datse of existing elements must be kept as is
     */
    /*
    static
    void
    computeDisplacement(
            ScenarioModel& scenario,
            const QVector<Id<TimeNodeModel>>& draggedElements,
            const TimeValue& deltaTime,
            ElementsProperties& elementsProperties) = 0;*/

      /**
     * @brief updatePositions
     * @param elementsPropertiesToUpdate
     * @param useNewValues
     * if false, use old values of properties (undo)
     */
    template<typename ProcessScaleMethod>
    static
    void
    updatePositions(ScenarioModel& scenario, ProcessScaleMethod&& scaleMethod, ElementsProperties& elementsPropertiesToUpdate, bool useNewValues)
    {
        // update each affected timenodes
        for(auto& curTimenodePropertiesToUpdate_id : elementsPropertiesToUpdate.timenodes.keys())
        {
            auto& curTimenodeToUpdate = scenario.timeNode(curTimenodePropertiesToUpdate_id);
            auto& curTimenodePropertiesToUpdate = elementsPropertiesToUpdate.timenodes[curTimenodePropertiesToUpdate_id];

            if(useNewValues)//redo
            {
               curTimenodeToUpdate.setDate(curTimenodePropertiesToUpdate.newDate);
            }else//undo
            {
               curTimenodeToUpdate.setDate(curTimenodePropertiesToUpdate.oldDate);
            }

            // update related events
            for (const auto& event : curTimenodeToUpdate.events())
            {
                scenario.event(event).setDate(curTimenodeToUpdate.date());
            }
        }

        // update affected constraints
        for(auto& curConstraintPropertiesToUpdate_id : elementsPropertiesToUpdate.constraints.keys())
        {
            auto& curConstraintToUpdate = scenario.constraint(curConstraintPropertiesToUpdate_id);
            //auto& curConstraintPropertiesToUpdate = elementsPropertiesToUpdate.constraints[curConstraintPropertiesToUpdate_id];

            const auto& startDate = scenario.event(scenario.state(curConstraintToUpdate.startState()).eventId()).date();
            const auto& endDate = scenario.event(scenario.state(curConstraintToUpdate.endState()).eventId()).date();

            TimeValue newDuration = endDate - startDate;

            if (!(curConstraintToUpdate.startDate() - startDate).isZero())
            {
                curConstraintToUpdate.setStartDate(startDate);
            }

            if(!(curConstraintToUpdate.duration.defaultDuration() - newDuration).isZero())
            {
                ConstraintDurations::Algorithms::setDurationInBounds(curConstraintToUpdate, newDuration);
                for(auto& process : curConstraintToUpdate.processes)
                {
                    scaleMethod(process, newDuration);
                }
            }

            emit scenario.constraintMoved(curConstraintToUpdate);
        }
    }
};

class GoodOldDisplacementPolicy
{
public:
    static
    void
    computeDisplacement(
            ScenarioModel& scenario,
            const QVector<Id<TimeNodeModel>>& draggedElements,
            const TimeValue& deltaTime,
            ElementsProperties& elementsProperties);

    static QString name()
    {
        return QString{"Old way"};
    }

    template<typename ProcessScaleMethod>
    static
    void
    updatePositions(ScenarioModel& scenario, ProcessScaleMethod&& scaleMethod, ElementsProperties& elementsPropertiesToUpdate, bool useNewValues)
    {
        CommonDisplacementPolicy::updatePositions(scenario, scaleMethod, elementsPropertiesToUpdate, useNewValues);
    }
};


namespace StandardDisplacementPolicy
{
    // pick out each timeNode that need to move when firstTimeNodeMovedId is moving
    void getRelatedTimeNodes(
            ScenarioModel& scenario,
            const Id<TimeNodeModel>& firstTimeNodeMovedId,
            QVector<Id<TimeNodeModel> >& translatedTimeNodes);


    template<typename ProcessScaleMethod>
    void updatePositions(
            ScenarioModel& scenario,
            const QVector<Id<TimeNodeModel> >& translatedTimeNodes,
            const TimeValue& deltaTime,
            ProcessScaleMethod&& scaleMethod)
    {
        for (const auto& timeNode_id : translatedTimeNodes)
        {
            auto& timeNode = scenario.timeNode(timeNode_id);
            timeNode.setDate(timeNode.date() + deltaTime);
            for (const auto& event : timeNode.events())
            {
                scenario.event(event).setDate(timeNode.date());
            }
        }

        for(auto& constraint : scenario.constraints)
        {
            const auto& startDate = scenario.event(scenario.state(constraint.startState()).eventId()).date();
            const auto& endDate = scenario.event(scenario.state(constraint.endState()).eventId()).date();

            TimeValue newDuration = endDate - startDate;

            if (!(constraint.startDate() - startDate).isZero())
            {
                constraint.setStartDate(startDate);
            }

            if(!(constraint.duration.defaultDuration() - newDuration).isZero())
            {
                ConstraintDurations::Algorithms::setDurationInBounds(constraint, newDuration);
                for(auto& process : constraint.processes)
                {
                    scaleMethod(process, newDuration);
                }
            }

            emit scenario.constraintMoved(constraint);
        }
    }
}
