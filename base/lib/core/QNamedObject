#pragma once
#include <QObject>
#include <QWidget>
#include <QGraphicsObject>
#include <QDebug>

////////////////////////////////////////////////
// This file contains utility algorithms & classes that can be used
// everywhere (core, plugins...)
////////////////////////////////////////////////
template<typename QType>
class QNamedType : public QType
{
	public:
		template<typename... Args>
		QNamedType(QType* parent, QString name, Args&&... args):
			QType{std::forward<Args>(args)...}
		{
			QType::setObjectName(name);
			QType::setParent(parent);
		}
};



using QNamedObject = QNamedType<QObject>;
using QNamedGraphicsObject = QNamedType<QGraphicsObject>;
using QNamedWidget = QNamedType<QWidget>;


class QIdentifiedObject : public QNamedObject
{
	public:
		template<typename... Args>
		QIdentifiedObject(QObject* parent,
						QString name,
						int id,
						Args&&... args):
			QNamedObject{parent,
						 name,
						 std::forward<Args>(args)...},
			m_id{id}
		{

		}

		int id() const
		{
			return m_id;
		}

		void setId(int id)
		{
			m_id = id;
		}

	private:
		int m_id{};
};

////////////////////////////////////////////////
template<typename Container>
typename Container::value_type findById(const Container& c, int id)
{
	auto it = std::find_if(std::begin(c),
						   std::end(c),
						   [&id] (typename Container::value_type model)
							{
							  return model->id() == id;
							});

	if(it != std::end(c))
		return *it;

	return nullptr;
}


////////////////////////////////////////////////
#include <QApplication>
struct ObjectIdentifier
{
		QString child_name;
		int id;
		//bool use_id = true;
};


inline QDataStream& operator <<(QDataStream& s, const ObjectIdentifier& obj)
{
	s << obj.child_name << obj.id;
	return s;
}

inline QDataStream& operator >>(QDataStream& s, ObjectIdentifier& obj)
{
	s >> obj.child_name >> obj.id;
	return s;
}

// TODO Find way for an object to give his own path
class ObjectPath
{
	public:
		ObjectPath() = default;
		// Creates a path object going from the (named) object with the "origin" name, to the identified object obj.
		static ObjectPath pathFromObject(QString origin, QIdentifiedObject* obj)
		{
			std::vector<ObjectIdentifier> v;
			QObject* obj_origin = qApp->findChild<QObject*>(origin);

			auto parent = obj;
			while(parent != obj_origin)
			{
				v.push_back({parent->objectName(), parent->id()});

				auto tmp_parent = parent;
				parent = dynamic_cast<QIdentifiedObject*>(tmp_parent->parent());
				if(!parent)
				{
					auto parent2 = dynamic_cast<QObject*>(tmp_parent->parent());
					if(parent2 && parent2->objectName() == origin)
					{
						break;
					}

					throw std::runtime_error("Could not find parent object");
				}
			}

			std::reverse(std::begin(v), std::end(v));

			return {origin, v};
		}

		ObjectPath(const ObjectPath& obj) = default;
		ObjectPath(ObjectPath&&) = default;

		QString baseObject;
		std::vector<ObjectIdentifier> v;

		QObject* find()
		{
			QObject* obj = qApp->findChild<QObject*>(baseObject);

			for(auto it = v.begin(); it != v.end(); ++it)
			{
				if(it->id != -1) // TODO : instead use a Value class that can be Uninitialized
				{
					auto childs = obj->findChildren<QIdentifiedObject*>(it->child_name, Qt::FindDirectChildrenOnly);

					auto elt = findById(childs, it->id);
					if(!elt)
					{
						return nullptr;
					}

					obj = elt;
				}
				else
				{
					auto child = obj->findChild<QNamedObject*>(it->child_name, Qt::FindDirectChildrenOnly);
					if(!child)
					{
						return nullptr;
					}

					obj = child;
				}
			}

			return obj;
		}
};

inline QDataStream& operator <<(QDataStream& s, const ObjectPath& path)
{
	s << path.baseObject;
	s << QVector<ObjectIdentifier>::fromStdVector(path.v);
	return s;
}

inline QDataStream& operator >>(QDataStream& s, ObjectPath& path)
{
	s >> path.baseObject;
	QVector<ObjectIdentifier> vec;
	s >> vec;

	path.v = vec.toStdVector();
	return s;
}

#define DEMO_PIXEL_SPACING_TEST 5

template <typename Vector>
int getNextId(Vector& v)
{
	if(v.size() == 0) 
	{
		return 0;
	}
	
	std::vector<int> ids(v.size()); // Map reduce
	std::transform(std::begin(v), 
				   std::end(v), 
				   std::begin(ids), 
				   [] (typename Vector::value_type elt) { return elt->id(); });
	
	return *(std::max_element(std::begin(ids),
							  std::end(ids))) + 1;
}