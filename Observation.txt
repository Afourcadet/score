------------------- Code en cours

* Poser la fin d'une relation (Cmd+click drag et mouseRelease) dans un TimeEvent déjà existant.
Pour l'instant on crée forcément un TimeEvent (TE) de fin, on veut pouvoir récupérer un pointeur sur ce TE déjà existant pour seulement créer une Timebox (TB) entre les deux.
Il faudrait arranger la méthode PluginView::mouseReleaseEvent() pour qu'elle teste si un TimeEvent est sous la souris, si c'est le cas on enverrait un signal createTimebox().
Comme il n'est pas possible de passer plusieurs valeurs dans un même signal, deux solutions ensuite pour récupérer un pointeur sur ce TE de fin, 
	Créer une nouvelle classe héritant de QObject et avec deux attributs : QLineF et TimeEventView*
	Rajouter un attribut dans TimeEventView pour stocker un pointeur sur ce TE de fin, puis Timebox::createTimeEventAndTimebox() devra chercher cet attribut (suppose une chaîne de méthode getter)
Voilà un exemple de code
void TimeEventView::mouseReleaseEvent(QGraphicsSceneMouseEvent *mouseEvent)
{
  if (_pTemporaryRelation != nullptr) {
      //If temporaryRelation is bigger enough
      if (abs(_pTemporaryRelation->line().dx()) > MIN_BOX_WIDTH) {
          QLineF line = _pTemporaryRelation->line();
          line.translate(mapToScene(line.p1())); 
--->		
		TimeEventView *endTE = qgraphicscastitem<TimeEventView*>(scene()->views().first()->itemAt(mouseEvent->scenePos().toPoint()))
		if ( endTE != 0))
			emit createTimebox(line);
		else
          	emit createTimeEventAndTimebox(line);
--->
        }
      delete _pTemporaryRelation;
      _pTemporaryRelation = nullptr;
    }
  QGraphicsObject::mouseReleaseEvent(mouseEvent);
}

* Changement de la taille d'une TB par manipulation des TE. 
TimeEventView::mousePressEvent() envoit un signal à TimeboxModel::settime() ou settimeEnd() avec un recalcul de TimeboxModel::width (qu'il faudra lier par observation avec TimeboxSmallView::width).
Info : La taille d'un plugin dépend de son boudingRect, qui est calculé statiquement dans le constructeur de PluginView. Il faudrait faire hériter cette dernière de QGraphicsWidget pour avoir une gestion de layout.

* édition en multi hérarchie. ex : pouvoir ajouter un TE dans une TB en smallView.
Les deux méthodes Timebox::addChild() doivent être adaptées dans le cas où la boîte est en smallView (elle peut récup cette info chez TimeboxPresenter).
Dans ce cas la TB ou TE créée doit avoir pour parent la TB en smallView. Le presenter de cette TB devra aussi s'assurer de rajouter ce nouvel enfant si elle passe en mode fullView.

------------- Problèmes

* RubberBandDrag (select dans la toolbar) ne s'affiche pas et ne selectionne pas les items dans le plugin ScenarioView. Je pense que le rectangle de selection s'affiche derrière le plugin Scenario, et que le problème vient du fait que le boundingRect de ScenarioView fait la taille du storey.

* Storey
+ suppression d'un storey fait remonter celui de dessous. Au lieu de corriger la version actuelle, plutôt suivre la proposition de Pascal (maquetteI-score0.3.pdf) qui facilitera la tâche.
Changer le contenu de la TimeboxStoreyBar (bandeau de storey) et la positionner en haut de la TimeboxStorey. On ajoute sous la première une autre Storey en mode replié (seul la TimeboxStoreyBar affichée) autre en bas pour l'ajout. 
+ 

* plugin Scenario n'est pas le parent des objets graphiques, c'est TimeboxFullView. 
**TimeboxPresenter devra repositionner les objets graphiques en cas de changement du storey hébergeant le plugin Scenario.
** Débordement lors d'un ajout de storey dans une TB 

* GraphicsView
Resize de la GraphicsView (remarques générales)
	incidence sur les élements est différent en fonction du Scenario actuel et de ses plugins, du resize horizontal ou vertical
		si actualScenario == mainScenario
			si graphicsView.width < Scenario.width alors Scrollbar
			sinon 
				Scenario s'élargit sans zoomer ses enfants et ne s'actualise pas avant l'ajout d'un élément
					Remarques
						Durée peut augmenter car non contraint par un scénario parent.
						Si une timebox fille est reliée en dur au EndEvent du Scenario ? On ne peut pas resizer la graphicsView ou on resize le contenu du scénario !  
						Automation étant accroché au EndEvent, sa durée augmente
		sinon actualScenario != mainScenario (enfant fixé par parent)
			contraint donc 
				Implémentation actuelle : zone grise dans background de la graphicsView
				Implémentation désirée : resize automatique pour tous les plugins (fitInView)
	Un resize en Y ne fait que déplacer les HUD (head up display), qui prennent et partagent la place automatiquement

-------------- Divers

* MainWindow::addItem() n'est pas utilisé et peut être dangereux si on ajoute un objet en dehors d'une TB. Préferer la méthode d'ajout par le plugin Scenario qui fait des tests de taille. Je ne l'ai pas supprimée car elle montre des mécanismes Qt intéressants, mais il faudrait tout de même s'y résoudre.
